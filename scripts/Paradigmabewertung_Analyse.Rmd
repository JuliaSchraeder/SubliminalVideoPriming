---
title: "Paradigma Questionnaire Analysis"
output: html_notebook
---

### Import Libraries

-   **`readxl`**: This package is used to read Excel files into R.

-   **`dplyr`**: A package for data manipulation, providing functions to filter, summarize, and transform data.

-   **`ggplot2`**: A powerful package for creating visualizations in R, allowing for complex and customizable plots.

install.packages("ggprism")

```{r}
library(readxl)
library(dplyr)
library(ggplot2)
library(writexl)
library(tidyr)
library(purrr)  # Load the purrr package for the reduce function
library(stringr)
library(grid)
library(cowplot)
library(ggprism)
```

### Import Dataset

-   **`read_excel()`**: This function reads the Excel file into a data frame `df`.

-   **`col_types`**: Specifies the data types for each column, ensuring the data is imported correctly.

-   **`na = "NA"`**: Ensures that any "NA" text in the Excel file is treated as `NA` (missing data) in R.

-   **`writeexl`**: to write the results in excel sheets\

```{r}
df <- read_excel("C:/Users/juhoffmann/OneDrive - Uniklinik RWTH Aachen/Auswertung/FB/Paradigmabewertungen_with_Demographics.xlsx", 
    col_types = c("text", "text", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "text"), na = "NA")
#View(df)
output_dir = "C:/Users/juhoffmann/Desktop/paradigmafragebogen/"
```

### Convert the group and gender variables to factors for easier analysis

-   **`factor()`**: Converts the `Gender_f1_m2` and `Group_MDD1_HC2` columns into factors, which are categorical variables.

-   **`labels`**: Assigns human-readable labels ("Female", "Male" for gender; "MDD", "HC" for group) to the factor levels.

```{r}
df$Gender_f1_m2 <- factor(df$Gender_f1_m2, labels = c("Female", "Male"))
df$Group_MDD1_HC2 <- factor(df$Group_MDD1_HC2, labels = c("MDD", "HC"))
```

### Find duplicates

-   searching for duplicates in "EmoCon_ID" column

```{r}
# Find duplicates in the EmoCon_ID column
duplicates <- df[duplicated(df$EmoCon_ID), ]

# Print the rows with duplicated EmoCon_IDs
print(duplicates)
```

## Use only the subjects that do not have duplicates

```{r}
# Remove duplicates based on the EmoCon_ID column
df_unique <- df %>%
  distinct(EmoCon_ID, .keep_all = TRUE)

# Check the number of rows before and after removing duplicates
print(paste("Original number of rows:", nrow(df)))
print(paste("Number of rows after removing duplicates:", nrow(df_unique)))

```

### Descriptive Statistics

-   **`group_by(Group_MDD1_HC2)`**: Groups the data by the `Group_MDD1_HC2` factor (MDD and HC groups).

-   **`summarise(across(...))`**: Calculates summary statistics (mean and standard deviation) across all columns 6 til11 (which are the survey questions).

-   **`na.rm = TRUE`**: Ensures that `NA` values are ignored in the calculations.

```{r}
summary_stats <- df_unique %>%
  group_by(Group_MDD1_HC2) %>%
  summarise(across(5:13,
                   list(mean = ~mean(., na.rm = TRUE), 
                        sd = ~sd(., na.rm = TRUE))))
```

```{r}
print(summary_stats)
```

#### Pivot the table

```{r}
# Pivot the summary_stats table to a long format
summary_stats_long <- summary_stats %>%
  pivot_longer(
    cols = -Group_MDD1_HC2, # Pivot all columns except the grouping variable
    names_to = "variable",  # Put all column names into a single 'variable' column
    values_to = "value"      # Put all corresponding values into a 'value' column
  )
print(summary_stats_long)
```

```{r}
write_xlsx(summary_stats_long, "C:/Users/juhoffmann/OneDrive - Uniklinik RWTH Aachen/Auswertung/FB/Paradigma_FB_Descriptives.xlsx")
```

### Count answers

-   **Grouping the Data**:

    `group_by(Group_MDD1_HC2, !!sym(question_col))`

    -   **Purpose**: This line groups the data by the `Group_MDD1_HC2` column (which indicates whether the respondent is in the MDD or HC group) and by the specific question column (`question_col`) passed to the function.

    -   **`!!sym(question_col)`**:

        -   This part converts the `question_col` (which is passed as a string, e.g., "1.") into a symbol that `dplyr` can use to refer to a column in the data frame. The `!!` (bang-bang) operator is used to unquote the symbol so that `dplyr` recognizes it as a column name.

    -   **`group_by()`**: Groups the data so that any subsequent operations (like summarizing) are done separately for each combination of `Group_MDD1_HC2` and the answers in `question_col`.

-   **Counting the Occurrences**:

    `summarise(count = n(), .groups = 'drop')`

    -   **Purpose**: This line counts how many times each combination of `Group_MDD1_HC2` and answer (e.g., "1", "2", etc.) occurs in the data.

    -   **`count = n()`**:

        -   `n()` is a function that counts the number of rows in each group. The result is stored in a new column named `count`.

    -   **`.groups = 'drop'`**:

        -   This option is used to drop the grouping structure after the summary is calculated, which simplifies further operations. Without this, the result would still be grouped, which might cause issues with the next steps.

-   **Pivoting the Data**:

    `pivot_wider(names_from = !!sym(question_col),              names_prefix = paste0(question_col, "_"),             values_from = count,              values_fill = 0)`

-   pivot_wider(names_from = !!sym(question_col), names_prefix = paste0(question_col, "\_"), values_from = count, values_fill = 0)

    -   **Purpose**: This line reshapes the data so that each unique answer (e.g., "1", "2", "3", etc.) for the question becomes a separate column.

    -   **`names_from = !!sym(question_col)`**:

        -   This specifies that the new columns will be named based on the unique values in `question_col` (i.e., the possible answers to the question).

    -   **`names_prefix = paste0(question_col, "_")`**:

        -   Adds a prefix to each new column's name, where the prefix is the question column name followed by an underscore (`_`). This helps to distinguish between the columns belonging to different questions.

    -   **`values_from = count`**:

        -   This indicates that the values in the newly created columns should come from the `count` column, which was generated in the previous step.

    -   **`values_fill = 0`**:

        -   If there are any missing combinations (e.g., a group didn't choose a particular answer), this fills those missing values with `0` instead of `NA`.

```{r}
# Function to calculate counts for each possible answer in a specific question column
count_answers <- function(data, question_col) {
  data %>%
    group_by(Group_MDD1_HC2, !!sym(question_col)) %>%  # Group by group and the specific question column
    summarise(count = n(), .groups = 'drop') %>%  # Count occurrences of each answer
    pivot_wider(names_from = !!sym(question_col), 
                names_prefix = paste0(question_col, "_"),
                values_from = count, 
                values_fill = 0)  # Pivot the table so each answer is a column with a clear prefix
}

# Apply the function to each question column (6 to 13)
count_list <- lapply(colnames(df_unique)[6:14], function(col) count_answers(df, col))

# Combine all count data frames into one
counts_combined <- reduce(count_list, full_join, by = "Group_MDD1_HC2")

# Print the combined counts table to verify
print(counts_combined)
```

```{r}
write_xlsx(counts_combined,'C:/Users/juhoffmann/OneDrive - Uniklinik RWTH Aachen/Auswertung/FB/Paradigma_FB_Counts.xlsx')
```

#### Plot counted data

```{r}
# Pivot the combined counts data to a long format for easier plotting
counts_long <- counts_combined %>%
  pivot_longer(
    cols = -Group_MDD1_HC2,  # Keep Group_MDD1_HC2 as is, pivot the rest
    names_to = c("question", "response"),  # Split the column names into 'question' and 'response'
    names_sep = "_",  # The separator used in the column names
    values_to = "count"  # The values in these columns will be moved to a column named 'count'
  )

# Print the first few rows to verify
print(head(counts_long))
```

```{r}
# Full question titles
question_titles <- c(
  "Gab es nach Ihrer Auffassung jede gezeigte Emotion gleich oft?",
  "Wie schätzen Sie Ihre Beurteilung der Emotionen ein?",
  "Wie fanden Sie die Länge des Experimentes?",
  "Haben Sie die Bilder, die wärend der Filmszenen gezeigt wurden, bemerkt?",
  "Wenn ja, wissen Sie, welche Emotionen auf diesen Bildern gezeigt wurden?",
  "Wie schwierig war die objektive Beurteilung der Videos für Sie (nach traurig, neutral glücklich)?",
  "Wie schwierig war die subjektive Beurteilung der Videos für Sie? (von traurig bis glücklich)",
  "Wie emotional berührt waren Sie von den Videos?",
  "Welche Strategie haben Sie bei den Bewertungen der Videos angewandt?"
)
```

```{r}
response_legends <- list(
  "Gab es nach Ihrer Auffassung jede gezeigte Emotion gleich oft?" = c(
    "1" = "1. More happy pictures",
    "2" = "2. More sad pictures",
    "3" = "3. More neutral pictures",
    "4" = "4. All equally often"
  ),
  "Wie schätzen Sie Ihre Beurteilung der Emotionen ein?" = c(
    "1" = "1. Easy",
    "2" = "2. Rather easy",
    "3" = "3. Medium",
    "4" = "4. Rather difficult",
    "5" = "5. Difficult",
    "6" = "6. I'm not sure"
  ),
  "Wie fanden Sie die Länge des Experimentes?" = c(
    "1" = "1. Too long",
    "2" = "2. Too short",
    "3" = "3. Appropriately long"
  ),
  "Haben Sie die Bilder, die wärend der Filmszenen gezeigt wurden, bemerkt?" = c(
    "1" = "1. Yes ",
    "2" = "2. No "
  ),
  "Wenn ja, wissen Sie, welche Emotionen auf diesen Bildern gezeigt wurden?" = c(
    "1" = "1. Mostly sad faces ",
    "2" = "2. Mostly happy faces ",
    "3" = "3. Mostly neutral faces ",
    "4" = "4. Equal",
    "5" = "5. I don't know "
  ),
  "Wie schwierig war die objektive Beurteilung der Videos für Sie (nach traurig, neutral glücklich)?" = c(
    "1" = "1. Easy ",
    "2" = "2. Rather easy ",
    "3" = "3. Medium ",
    "4" = "4. Rather difficult ",
    "5" = "5. Difficult ",
    "6" = "6. I'm not sure "
  ),
  "Wie schwierig war die subjektive Beurteilung der Videos für Sie? (von traurig bis glücklich)" = c(
    "1" = "1. Easy ",
    "2" = "2. Rather easy ",
    "3" = "3. Medium ",
    "4" = "4. Rather difficult ",
    "5" = "5. Difficult ",
    "6" = "6. I'm not sure "
  ),
  "Wie emotional berührt waren Sie von den Videos?" = c(
    "1" = "1. Not at all ",
    "2" = "2. Rather not ",
    "3" = "3. Medium ",
    "4" = "4. Somewhat ",
    "5" = "5. Very "
  ),
  "Welche Strategie haben Sie bei den Bewertungen der Videos angewandt?" = c(
    "1" = "1. Always same \n(objective and subjective) ",
    "2" = "2. Mostly same \n(objective and subjective) ",
    "3" = "3. Independant \n(objective and subjective) ",
    "4" = "4. Other "
  )
)
```

```{r}
# English translations of the question titles
question_titles <- c(
  "Did you think each displayed emotion appeared equally often?",
  "How would you rate your judgment of the emotions?",
  "How did you find the length of the experiment?",
  "Did you notice the pictures \nshown during the film scenes?",
  "If yes, do you know which emotions \nwere shown in these pictures?",
  "How difficult was the objective \nassessment of the videos for you \n(based on sad, neutral, happy)?",
  "How difficult was the subjective \nassessment of the videos for you? \n(from sad to happy)",
  "How emotionally affected \nwere you by the videos?",
  "What strategy did you use \nwhen evaluating the videos?"
)
# Function to plot a specific question with its title and response legend
plot_question <- function(question_number) {
  # Filter the data for the specific question
  data <- counts_long %>% 
    filter(question == question_number) %>%
    mutate(response_text = recode(response,
                                  !!!response_legends[[question_number]]))
  # Map numeric responses to text
  
  # Get the translated title for the specific question
  question_title <- question_titles[which(questions == question_number)]
  
  # Calculate the maximum count and set y-axis limits from 0 to max_count + 5
  max_count <- max(data$count, na.rm = TRUE)
  y_limits <- c(0, max_count + 5)
  
  # Create the plot
  p <- ggplot(data, aes(x = response_text, 
                        y = count, 
                        fill = Group_MDD1_HC2)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(aes(label = count), 
              position = position_dodge(width = 0.9),
              size = 4,
              vjust = 0) + # Adjust the position of the text
    labs(title = question_title,
         x = "",
         y = "Count") +
    scale_fill_manual(values = c("MDD" = "#FF9999", "HC" = "#9999FF"), 
                      name = "Group") +
    scale_y_continuous(limits = y_limits) + # Set y-axis to max_count + 5
    theme_prism() +
    theme(axis.text.x = element_text(angle = 45, 
                                     hjust = 1,
                                     vjust = 1,
                                     # Move x-axis labels 
                                     margin = margin(t = 0, b = 0)),
          axis.title.x = element_text(margin = margin(t = 10)), # Move x-axis title
          plot.title = element_text(margin = margin(b = 30)),  # Move plot title up
          plot.margin = unit(c(0.5, 0.5, 0.5, 2),"cm"))  # Adjust the plot marginsangle
  
  return(p)
}

# Get a list of unique questions
questions <- unique(counts_long$question)

plots <- list()
# Plot and save each question
for (q in questions) {
  p <- plot_question(q)
  print(p)  # Display the plot
  plots[[q]] <- p
}
```

## Save plots

```{r}
one <- plots[[1]]
two<- plots[[2]]
three<- plots[[3]]
four<- plots[[4]]
five<- plots[[5]]
six<- plots[[6]]
seven<- plots[[7]]
eight<- plots[[8]]
nine<- plots[[9]]
  
cowplot::save_plot(filename = "Q1.png", plot = one, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q2.png", plot = two, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q3.png", plot = three, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q4.png", plot = four, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q5.png", plot = five, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q6.png", plot = six, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q7.png", plot = seven, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q8.png", plot = eight, base_height = 5, base_width = 5)
cowplot::save_plot(filename = "Q9.png", plot = nine, base_height = 5, base_width = 6)

```

```{r}
# Combine the first three plots into one
combined_plot_1 <- cowplot::plot_grid(plotlist = plots[4:5], ncol = 1)

combined_plot_2 <- cowplot::plot_grid(plotlist = plots[6:7], ncol = 1)

combined_plot_3 <- cowplot::plot_grid(plotlist = plots[8:9], 
                                      ncol = 2, nrow = 1,
                                      vjust = 1, hjust = 1)
#print(combined_plot_1)
print(combined_plot_2)
print(combined_plot_3)


```

```{r}
# Save the combined plots
cowplot::save_plot("combined_plot_1.png", plot = combined_plot_1, base_height = 9, base_width = 5)
cowplot::save_plot("combined_plot_2.png", plot = combined_plot_2, base_height = 10, base_width = 7)
cowplot::save_plot("combined_plot_3.png", plot = combined_plot_3, base_height = 7, base_width = 10)
```

## Statistics

```{r}
library(afex)

# Reshape the data to long format
df_long <- df_unique %>%
  pivot_longer(cols = starts_with("Gab"), # Adjust this to include all question columns
               names_to = "Question",
               values_to = "Response")

# Run repeated measures ANOVA
anova_results <- aov_ez(id = "EmoCon_ID",  # Use the participant ID column
                        dv = "Response",
                        within = "Question",
                        between = "Group_MDD1_HC2",
                        data = df_long)

# View the results
summary(anova_results)
```

```{r}
df_long

```

## add p values to plot

```{r}
p_vals <- tibble::tribble(
  ~group1, ~group2, ~p.adj,   ~y.position,
  "0.5",   "1",     8.80e-14, 35,
  "0.5",   "2",     1.27e-7,  39
)
add_pvalue(p_vals, label = "p = {p.adj}", tip.length = 0, label.size = 4)
```

## Tests

```{r}
{r}
plot_question <- function(question_number, width = 8, height = 6) {
  # Filter the data for the specific question
  data <- counts_long %>% filter(question == question_number)
  
  # Get the title for the specific question
  question_title <- question_titles[which(question_titles == question_number)]
  
  # Get the response legend for the specific question
  response_legend <- response_legends[[question_number]]
  legend_text <- paste(names(response_legend), 
                       response_legend, sep = ": ",
                       collapse = "\n")
  
  # Determine the maximum count and add 5 for the y-axis limit
  max_count <- max(data$count)
  y_limits <- c(0, max_count + 5)
  
  # Create the plot
  p <- ggplot(data, aes(x = response, y = count, fill = Group_MDD1_HC2)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = question_title,
         x = "",
         y = "Count") +
    scale_fill_manual(values = c("MDD" = "#FF9999", "HC" = "#9999FF"), 
                      name = "Group") +
    scale_y_continuous(limits = y_limits) +  # Apply the y-axis limits
    theme_prism()
  
  # Create the legend as a separate text grob
  legend_grob <- grid::textGrob(legend_text, x = 0, hjust = 0, vjust = 1, 
                                gp = grid::gpar(fontsize = 12, fontface = "italic"))
  
  # Combine the plot and legend using cowplot
  combined_plot <- cowplot::plot_grid(p, legend_grob, ncol = 1, rel_heights = c(1, 0.6), align = "v", axis = "lt")
  
  return(combined_plot)
}

# Get a list of unique questions
questions <- unique(counts_long$question)

plots <- list()
# Plot and save each question
for (q in questions) {
  p <- plot_question(q)
  print(p)  # Display the plot
  plots[[q]] <- p
}
```

```{r}
plot_question <- function(question_number) {
  # Filter the data for the specific question
  data <- counts_long %>% filter(question == question_number)
  
  # Get the title for the specific question
  question_title <- question_titles[which(question_titles == question_number)]
  
  # Get the response legend for the specific question
  response_legend <- response_legends[[question_number]]
  legend_text <- paste(names(response_legend), response_legend, sep = ": ", collapse = "\n")
  
  # Create the plot
  p <- ggplot(data, aes(x = response, y = count, fill = Group_MDD1_HC2)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = question_title,
         x = "",
         y = "Count") +
    scale_fill_manual(values = c("MDD" = "#FF9999", "HC" = "#9999FF"), 
                      name = "Group") +
    theme_prism()
  
  # Create the legend as a separate text grob
  legend_grob <- grid::textGrob(legend_text, x = 0, hjust = 0, vjust = 1, 
                                gp = grid::gpar(fontsize = 12, fontface = "italic"))
  
  # Combine the plot and legend using cowplot
  combined_plot <- cowplot::plot_grid(p, legend_grob, ncol = 1, rel_heights = c(1, 0.6), align = "h", axis = "lt")
  
  return(combined_plot)
}

# Get a list of unique questions
questions <- unique(counts_long$question)

plots <- list()
# Plot and save each question
for (q in questions) {
  p <- plot_question(q)
  print(p)  # Display the plot
  plots[[q]] <- p
}
```
